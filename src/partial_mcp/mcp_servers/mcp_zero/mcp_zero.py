"""
MCP Zero
--------
This module contains the toolset class compatible with MCP Zero's format
as well as utility functions for working with their json file.
"""

from pathlib import Path

from pydantic import BaseModel, TypeAdapter
from pydantic_ai import RunContext, ToolsetTool
from pydantic_ai.tools import ToolDefinition

from ..disable_toolcall import DisableToolcall


class MCPZeroTool(BaseModel):
    """A single tool in MCP Zero's format."""

    name: str
    description: str
    parameter: dict[str, str]
    """
    Mapping from parameter names to their descriptions.

    The descriptions sometimes contain parameter type in an arbitrary format.
    That is due to descriptions being generated by LLMs in the original
    MCP Zero dataset.
    """

    def to_tool_def(self) -> ToolDefinition:
        """Convert this tool to pydantic_ai's ToolDefinition object."""
        return ToolDefinition(
            name=self.name,
            description=self.description,
            parameters_json_schema={
                "type": "object",
                "properties": {
                    name: {"description": description}
                    for name, description in self.parameter.items()
                },
            },
        )


class MCPZero(BaseModel, DisableToolcall):
    """Toolset defined in MCP Zero's format."""

    name: str
    description: str
    url: str
    tools: list[MCPZeroTool]

    @property
    def id(self) -> str:
        return self.name

    async def get_tools(self, ctx: RunContext) -> dict[str, ToolsetTool]:
        return {  # combine toolset's name and the tools's names to avoid tool name collisions
            f"{self.name}-{tool.name}": self.tool_to_toolset_tool(tool)
            for tool in self.tools
        }

    def tool_to_toolset_tool(self, tool: MCPZeroTool) -> ToolsetTool:
        """Utility function to convert MCPZeroTool object into pydantic_ai's ToolsetTool object."""
        return ToolsetTool(
            tool_def=tool.to_tool_def(),
            toolset=self,
            max_retries=0,
            args_validator=TypeAdapter(  # pyrefly: ignore[bad-argument-type]
                dict
            ).validator,
            # for some reason PluggableSchemaValidator does not get accepted as SchemaValidatorProt
        )


def get_mcp_zero_toolsets(
    path: str | Path = Path(__file__).parent / "toolsets.json",
) -> list[MCPZero]:
    """
    Create a list of MCPZero toolsets from the file created by `clean_mcp_toolsets_file`.
    Additionally, remove toolsets with the same name leaving only the first one.
    """
    if not Path(path).exists():
        raise FileNotFoundError(f"MCP Zero toolset json not found at location: {path}")
    with open(path, "r") as f:
        toolsets = TypeAdapter(list[MCPZero]).validate_json(f.read())

    # remove toolsets with repeating names
    toolset_names: set[str] = set()
    result: list[MCPZero] = []
    for toolset in toolsets:
        if toolset.name in toolset_names:
            continue
        toolset_names.add(toolset.name)
        result.append(toolset)
    return result


def clean_mcp_toolsets_file(
    path: str | Path = Path(__file__).parent / "mcp_tools_with_embedding.json",
):
    """
    Pre-process MCPZero's toolset dataset by removing extra data such as embeddings
    and save the new dataset to `toolsets.json` file.

    Link to the original dataset:
    https://github.com/xfey/MCP-Zero/blob/master/MCP-tools/download_data.md
    """
    if not Path(path).exists():
        raise FileNotFoundError(f"MCP Zero toolset json not found at location: {path}")
    mcp_zero_list = TypeAdapter(list[MCPZero])
    with open(path, "r") as f:
        toolsets = mcp_zero_list.validate_json(f.read())
    with open(Path(__file__).parent / "toolsets.json", "wb") as wb:
        wb.write(mcp_zero_list.dump_json(toolsets, indent=4))
